#ifndef OURS_H
#define OURS_H
// #define MEASUREACC
// #define MEASURETIME
#include "Abstract.h"

/**
 * Template for OctoSketch running in multiple cores
 */

template <typename Key, typename Entry, uint32_t thread_num>
class Ours : public Abstract
{
private:
    struct alignas(64) Paddedbool
    {
        bool value;
    };
    std::vector<uint32_t> queue_lengths;
    std::vector<uint32_t> processed_packets_nums;
    std::unordered_map<Key, uint64_t> thd_ground_truth[thread_num];
    std::condition_variable cv;
    std::mutex cv_m;
    std::atomic<bool> is_querying;
    std::unordered_set<Key> keyset;
    std::atomic<uint32_t> partition_num;
    Paddedbool thd_pause_flag[thread_num];
    double running_time[thread_num];
    uint32_t dataset_size[thread_num];

public:
    // static weak_atomic<int32_t> PROMASK;
    typedef ReaderWriterQueue<Entry> myQueue;
    struct alignas(64) PaddedUint32
    {
        uint32_t value;
    };
    PaddedUint32 thd_processed_packets_num[thread_num];
    myQueue que[thread_num];

    virtual Sketch<Key> *initialize_parent() = 0;
    virtual Sketch<Key> *initialize_child() = 0;

    virtual void merge(Sketch<Key> *sketch, Entry temp) = 0;
    // virtual void modify_threshold() = 0;
    virtual void insert_child(Sketch<Key> *sketch, myQueue &q, const Key &packet) = 0;

    void update(void *start, uint64_t size, HashMap mp)
    {
        size = size/5;
        std::thread parent;
        parent = std::thread(&Ours::ParentThread, this, &parent, start, size, &mp);
        parent.join();
    }

    /**
     * The thread of the aggregator
     */
    void ParentThread(std::thread *thisThd, void *start, uint32_t size, HashMap *mp)
    {
#ifdef __linux__
        if (!setaffinity(thisThd, thread_num))
            return;
#endif
        std::atomic<int32_t> finish(0);
        std::thread thd[thread_num];
        std::thread measure_thd;
        partition_num.store(0);
        is_querying.store(false);
        // measure_thd = std::thread(&Ours::measurequeuelength, this, &measure_thd, &finish);
        Sketch<Key> *sketch = initialize_parent();
#ifdef MEASUREACC
        Initkeyset((Key *)start, size / sizeof(Key), keyset);
        for (auto it = keyset.begin(); it != keyset.end(); it++)
        {
            for (uint32_t i = 0; i < thread_num; i++)
                thd_ground_truth[i][*it] = 0;
        }
#endif
        // std::thread query_thd = std::thread(&Ours::QueryThread, this, &query_thd, sketch, &finish);
        for (uint32_t i = 0; i < thread_num; ++i)
        {
            thd_pause_flag[i].value = false;
            thd_processed_packets_num[i] = PaddedUint32{0};
            thd[i] = std::thread(&Ours::ChildThread, this,
                                 &(thd[i]), i, start, size, &finish);
        }
        while (partition_num < thread_num)
        {
        }
        auto start_time = std::chrono::high_resolution_clock::now();
        collect(sketch, finish);
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::milli> duration = end_time - start_time;
        // std::cout << "running time: " << duration.count() << " ms" << std::endl;
        for (uint32_t i = 0; i < thread_num; ++i)
        {
            thd[i].join();
        }
        // measure_thd.join();
#ifdef MEASURETIME
        double avg_time = 0;
        for (uint32_t i = 0; i < thread_num; i++)
        {
            avg_time += running_time[i];
            std::cout << "thread id: " << i << " dataset size: " << dataset_size[i] << " running time: " << running_time[i] << std::endl;
        }
        std::cout << "avg: " << avg_time / thread_num << std::endl;
#endif
        std::cout << "Ours Accuracy:" << std::endl;
        // HashMap ret = sketch->query_all();
#ifdef MEASUREACC
        Query(sketch);
#else
        HashMap ret = sketch->query_all();
        HHCompare(ret, (*mp), size / sizeof(Key) * ALPHA);

#endif
        // HHCompare(ret, (*mp), size / sizeof(Key) * ALPHA);
        // #ifdef PRINTLENGTH
        // std::ofstream outputFile("queuelength" + std::to_string(thread_num) + ".txt");
        // for (auto len : queue_lengths)
        // {
        //     outputFile<< len << std::endl;
        // }
        // for (uint32_t i = 0; i < queue_lengths.size(); i++)
        // {
        //     if (processed_packets_nums[i] != 0)
        //         outputFile << processed_packets_nums[i] << " " << queue_lengths[i] << std::endl;
        // }
        // outputFile.close();
        // query_thd.join();
        // std::cout << "tot cnt: " << processed_packets_num << std::endl;
        // #endif
        delete sketch;
    }

    /**
     * The thread of each worker
     */
    void ChildThread(std::thread *thisThd, uint32_t thread_id, void *start, uint32_t size,
                     std::atomic<int32_t> *finish)
    {
#ifdef __linux__
        if (!setaffinity(thisThd, thread_id))
            return;
#endif
        Sketch<Key> *sketch = initialize_child();

        std::vector<Key> dataset;

        Partition<Key, thread_num>((Key *)start, size / sizeof(Key), thread_id, dataset);
        partition_num.fetch_add(1);
        while (partition_num < thread_num)
        {
        }
#ifdef MEASURETIME
        auto start_time = std::chrono::high_resolution_clock::now();
#endif
        sketch = insert(dataset, sketch, que[thread_id], thread_id);
#ifdef MEASURETIME
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::milli> duration = end_time - start_time;
        running_time[thread_id] = duration.count();
        dataset_size[thread_id] = dataset.size();
#endif
        // std::cout<<"thread: "<<thread_id<< " running time: " << duration.count() << " ms" << std::endl;
        (*finish)++;
#ifdef MEASUREACC
        for (uint32_t i = 0; i < thd_processed_packets_num[thread_id].value; i++)
            thd_ground_truth[thread_id][dataset[i]] += 1;
#endif
        delete sketch;
    }

    Sketch<Key> *insert(const std::vector<Key> &dataset, Sketch<Key> *sketch, myQueue &q, uint32_t thread_id)
    {
        uint32_t length = dataset.size();
        for (uint32_t i = 0; i < length; ++i)
        {
            // {
            //     std::unique_lock<std::mutex> lock(cv_m);
            //     cv.wait(lock, [this]
            //             { return !is_querying.load(); }); // 等待恢复信号
            // }
#ifdef MEASUREACC
            thd_processed_packets_num[thread_id].value += 1;
            if (thd_pause_flag[thread_id].value)
                return sketch;
#endif
            insert_child(sketch, q, dataset[i]);

        }

        return sketch;
    }
    void measurequeuelength(std::thread *thisThd, std::atomic<int32_t> *finish)
    {
        while (*finish < thread_num)
        {
            // std::this_thread::sleep_for(std::chrono::nanoseconds(1));
            uint32_t total = 0;
            uint32_t processed_packet_num = 0;
            for (uint32_t i = 0; i < thread_num; ++i)
            {
                processed_packet_num += thd_processed_packets_num[i].value;
                total += que[i].size_approx();
            }

            processed_packets_nums.emplace_back(processed_packet_num);
            queue_lengths.emplace_back(total);
            // std::cout << "processed packets: " << processed_packet_num << " Ours Delay: " << total << std::endl;
            // // if (total > 100 * thread_num)
            // // {
            // std::cout <<"packets: "<<processed_packet_num<<" Ours Delay: " << total << std::endl;
            // // }
        }
    }
    void QueryThread(std::thread *thisThd, Sketch<Key> *sketch, std::atomic<int32_t> *finish)
    {
        while (*finish < thread_num)
        {
            std::cout << "start query" << std::endl;
            // is_querying.store(true);
            HashMap ret = sketch->query_all();
            uint32_t processed_packets_num = 0;
            double estHH = 0, HH = 0, both = 0;
            double CR = 0, PR = 0, AAE = 0, ARE = 0;

            for (uint32_t i = 0; i < thread_num; i++)
                processed_packets_num += thd_processed_packets_num[i].value;
            uint32_t threshold = processed_packets_num * ALPHA;
            std::cout << threshold << std::endl;
            for (auto it = ret.begin(); it != ret.end(); ++it)
            {
                if (it->second > threshold)
                {
                    estHH += 1;
                    uint32_t cnt = 0;
                    for (uint32_t i = 0; i < thread_num; i++)
                        cnt += thd_ground_truth[i][it->first];
                    if (cnt > threshold)
                    {
                        both += 1;
                        AAE += abs((int)cnt - (int)it->second);
                        ARE += abs((int)cnt - (int)it->second) / (double)cnt;
                    }
                }
            }

            for (auto it = keyset.begin(); it != keyset.end(); ++it)
            {
                uint32_t cnt = 0;
                for (uint32_t i = 0; i < thread_num; i++)
                    cnt += thd_ground_truth[i][*it];
                if (cnt > threshold)
                {
                    HH += 1;
                }
            }
            // is_querying.store(false);
            // cv.notify_all();
            std::cout << "CR: " << both / HH << std::endl
                      << "PR: " << both / estHH << std::endl
                      << "AAE: " << AAE / both << std::endl
                      << "ARE: " << ARE / both << std::endl
                      << std::endl;
            std::this_thread::sleep_for(std::chrono::nanoseconds(1000));
        }
    }
    void Query(Sketch<Key> *sketch)
    {
        std::cout << "start query" << std::endl;
        // is_querying.store(true);
        HashMap ret = sketch->query_all();
        uint32_t processed_packets_num = 0;
        double estHH = 0, HH = 0, both = 0;
        double CR = 0, PR = 0, AAE = 0, ARE = 0;

        for (uint32_t i = 0; i < thread_num; i++)
            processed_packets_num += thd_processed_packets_num[i].value;
        std::cout << processed_packets_num << std::endl;
        uint32_t threshold = processed_packets_num * ALPHA;
        std::cout << threshold << std::endl;
        for (auto it = ret.begin(); it != ret.end(); ++it)
        {
            if (it->second > threshold)
            {
                estHH += 1;
                uint32_t cnt = 0;
                for (uint32_t i = 0; i < thread_num; i++)
                    cnt += thd_ground_truth[i][it->first];
                if (cnt > threshold)
                {
                    both += 1;
                    AAE += abs((int)cnt - (int)it->second);
                    ARE += abs((int)cnt - (int)it->second) / (double)cnt;
                }
            }
        }

        for (auto it = keyset.begin(); it != keyset.end(); ++it)
        {
            uint32_t cnt = 0;
            for (uint32_t i = 0; i < thread_num; i++)
                cnt += thd_ground_truth[i][*it];
            if (cnt > threshold)
            {
                HH += 1;
            }
        }
        // is_querying.store(false);
        // cv.notify_all();
        std::cout << "CR: " << both / HH << std::endl
                  << "PR: " << both / estHH << std::endl
                  << "AAE: " << AAE / both << std::endl
                  << "ARE: " << ARE / both << std::endl
                  << std::endl;
    }

    void collect(Sketch<Key> *sketch, std::atomic<int32_t> &finish)
    {
        Entry temp;
        uint64_t idx = 0;
        while (finish < thread_num)
        {
            // {
            //     std::unique_lock<std::mutex> lock(cv_m);
            //     cv.wait(lock, [this]
            //             { return !is_querying.load(); }); // 等待恢复信号
            // }
            // #ifdef QUEUELENGTH
            // if (processed_packets_num % 100000 == 0)
            // {
            //     uint32_t total = 0;
            //     for (uint32_t i = 0; i < thread_num; ++i)
            //     {
            //         total += que[i].size_approx();
            //     }
            //     // std::cout << "Ours Delay: " << total << std::endl;
            //     queue_lengths.emplace_back(total);
            // }
            // uint32_t total = 0;
            // for (uint32_t i = 0; i < thread_num; ++i)
            // {
            //     total += que[i].size_approx();
            // }
            // // if(total > 100 * thread_num){
            //     std::cout<< "Ours Delay: " << total << std::endl;
            // // }
            // queue_lengths.emplace_back(total);
            // #endif
            for (uint32_t i = 0; i < thread_num; ++i)
            {
                if (que[i].try_dequeue(temp))
                {
                    merge(sketch, temp);
                    // idx += 1;
                    // if (idx > 0x3f)
                    // {
                    //     idx = 0;
                    //     modify_threshold();
                    // }
                }
            }
            // idx += thread_num;
            // if (idx > 0x3f)
            // {
            //     idx = 0;
            //     modify_threshold();
            // }
#ifdef MEASUREACC
            if (finish > 0)
            {
                uint32_t processed_packet_num = 0;
                for (uint32_t i = 0; i < thread_num; ++i)
                {
                    processed_packet_num += thd_processed_packets_num[i].value;
                }
                for (uint32_t i = 0; i < thread_num; i++)
                    thd_pause_flag[i].value = true;
                std::cout << processed_packet_num << std::endl;
                break;
            }
#endif
        }
        uint32_t total = 0;
        for (uint32_t i = 0; i < thread_num; ++i)
        {
            total += que[i].size_approx();
        }
        std::cout << " Ours Delay: " << total << std::endl;
        for (uint32_t i = 0; i < thread_num; ++i)
        {
            while (que[i].try_dequeue(temp))
            {
                merge(sketch, temp);
            }
        }
    }
};
// template <typename Key, typename Entry, uint32_t thread_num>
// weak_atomic<int32_t> Ours<Key, Entry, thread_num>::PROMASK = 0x7;
#endif